#include "test_main.hxx"
#include "utils/ServiceLocator.hxx"

using namespace testing;

class SomeService
{
};

/**
 * Define a virtual interface that must be implemented, but contains the methods
 * the consumer wants to use.
 */
class OtherInterface
{
public:
    virtual const char *get_name() = 0;
};

class OtherImplementation1 : public OtherInterface
{
    const char *get_name() override { return "One"; };
};

class OtherImplementation2 : public OtherInterface
{
    const char *get_name() override { return "Two"; };
};

class ServiceLocatorTests : public Test
{
protected:
    SomeService service_;
};

TEST_F(ServiceLocatorTests, no_such_service)
{
    SomeService *some_service = ServiceLocator<SomeService>::get_service();

    EXPECT_EQ(nullptr, some_service);
}

TEST_F(ServiceLocatorTests, registered_simple)
{
    ServiceLocator<SomeService>::register_service(&service_);

    SomeService *service = ServiceLocator<SomeService>::get_service();
    EXPECT_EQ(&service_, service);

    OtherInterface *other = ServiceLocator<OtherInterface>::get_service();
    EXPECT_EQ(nullptr, other);
}

/**
 * You can register any implementation of an interface and always retrieve the
 * registered instance without knowing the class for the registered instance.
 */
TEST_F(ServiceLocatorTests, register_via_interface)
{
    OtherImplementation1 first;
    OtherImplementation2 second;

    ServiceLocator<OtherInterface>::register_service(&first);
    OtherInterface *service = ServiceLocator<OtherInterface>::get_service();
    EXPECT_EQ("One", service->get_name());

    ServiceLocator<OtherInterface>::register_service(&second);
    service = ServiceLocator<OtherInterface>::get_service();
    EXPECT_EQ("Two", service->get_name());
}
