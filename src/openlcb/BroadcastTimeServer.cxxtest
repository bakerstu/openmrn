#include "utils/async_if_test_helper.hxx"

#include "openlcb/BroadcastTimeServer.hxx"

#if 1
#define PRINT_ALL_PACKETS() print_all_packets()
#else
#define PRINT_ALL_PACKETS()
#endif

// test helper
::testing::AssertionResult IsBetweenInclusive(int val, int a, int b)
{
    if((val >= a) && (val <= b))
        return ::testing::AssertionSuccess();
    else
        return ::testing::AssertionFailure()
               << val << " is outside the range " << a << " to " << b;
}

namespace openlcb
{

class BroadcastTimeServerTest : public AsyncNodeTest
{
protected:
    BroadcastTimeServerTest()
    {
        PRINT_ALL_PACKETS();

        ::testing::Sequence s1;

        // sync sequence
        expect_packet(":X1954422AN010100000100F001;").InSequence(s1);
        expect_packet(":X1954422AN0101000001004000;").InSequence(s1);
        expect_packet(":X1954422AN01010000010037B2;").InSequence(s1);
        expect_packet(":X1954422AN0101000001002101;").InSequence(s1);
        expect_packet(":X1954422AN0101000001000000;").InSequence(s1);

        server_ = new BroadcastTimeServer(
            node_, BroadcastTimeDefs::DEFAULT_FAST_CLOCK_ID);
        wait_for_event_thread();
        server_->update_subscribe(
            std::bind(&BroadcastTimeServerTest::update_callback, this));

        clear_expect(true);
    }

    ~BroadcastTimeServerTest()
    {
        server_->shutdown();
        wait();
        twait();
        usleep(10000);
        while (!server_->is_shutdown())
        {
            usleep(10000);
            wait();
        }

        delete server_;
    }

    MOCK_METHOD0(update_callback, void());

    BroadcastTimeServer *server_;
};

TEST_F(BroadcastTimeServerTest, Create)
{
    // consumer/producer identify ranges
    expect_packet(":X1952422AN010100000100FFFF;");
    expect_packet(":X194A422AN0101000001008000;");

    send_packet(":X19970001N;");
    wait_for_event_thread();

    // time is not setup, clock is not running, expect 0 as default
    EXPECT_EQ(server_->time(), 0);
    EXPECT_EQ(server_->day_of_week(), BroadcastTimeDefs::THURSDAY);
    EXPECT_EQ(server_->day_of_year(), 0);
};

TEST_F(BroadcastTimeServerTest, StartSetTime)
{
    ::testing::Sequence s1, s2;

    // set events
    expect_packet(":X195B422AN0101000001000000;").InSequence(s1);
    expect_packet(":X195B422AN0101000001002101;").InSequence(s1);
    expect_packet(":X195B422AN01010000010037B2;").InSequence(s1);
    expect_packet(":X195B422AN01010000010047D0;").InSequence(s1);
    EXPECT_CALL(*this, update_callback()).Times(4);

    server_->set_time(0, 0);
    server_->set_date(1, 1);
    server_->set_year(1970);
    server_->set_rate(2000);
    wait_for_event_thread();

    clear_expect(true);

    // start
    expect_packet(":X195B422AN010100000100F002;").InSequence(s2);

    // sync seqeunce
    expect_packet(":X1954422AN010100000100F002;").InSequence(s2);
    expect_packet(":X1954422AN01010000010047D0;").InSequence(s2);
    expect_packet(":X1954422AN01010000010037B2;").InSequence(s2);
    expect_packet(":X1954422AN0101000001002101;").InSequence(s2);
    expect_packet(":X1954422AN0101000001000019;").InSequence(s2);
    expect_packet(":X195B422AN010100000100001A;").InSequence(s2);

    // callbacks on clock update
    EXPECT_CALL(*this, update_callback()).Times(1);

    server_->start();

    // allow time for the sync timeout
    sleep(3);
    wait_for_event_thread();

    // check the time, we give it a finite range just in case of some OS jitter
    EXPECT_TRUE(IsBetweenInclusive(server_->time(), 1500, 1501));
    EXPECT_EQ(server_->day_of_week(), BroadcastTimeDefs::THURSDAY);
    EXPECT_EQ(server_->day_of_year(), 0);
};

TEST_F(BroadcastTimeServerTest, DateRolloverForward)
{
    ::testing::Sequence s1, s2;

    // set events
    expect_packet(":X195B422AN010100000100173B;").InSequence(s1);
    expect_packet(":X195B422AN0101000001002101;").InSequence(s1);
    expect_packet(":X195B422AN01010000010037B2;").InSequence(s1);
    expect_packet(":X195B422AN01010000010047D0;").InSequence(s1);
    EXPECT_CALL(*this, update_callback()).Times(4);

    server_->set_time(23, 59);
    server_->set_date(1, 1);
    server_->set_year(1970);
    server_->set_rate(2000);
    wait_for_event_thread();

    clear_expect(true);

    // start
    expect_packet(":X195B422AN010100000100F002;").InSequence(s2);

    // date rollover
    expect_packet(":X195B422AN010100000100F003;").InSequence(s2);
    expect_packet(":X195B422AN0101000001000000;").InSequence(s2);

    // sync seqeunce
    expect_packet(":X1954422AN010100000100F002;").InSequence(s2);
    expect_packet(":X1954422AN01010000010047D0;").InSequence(s2);
    expect_packet(":X1954422AN01010000010037B2;").InSequence(s2);
    expect_packet(":X1954422AN0101000001002102;").InSequence(s2);
    expect_packet(":X1954422AN0101000001000018;").InSequence(s2);

    // date rollover continued
    expect_packet(":X195B422AN01010000010037B2;").InSequence(s2);
    expect_packet(":X195B422AN0101000001002102;").InSequence(s2);

    // sync sequence continued
    expect_packet(":X195B422AN0101000001000019;").InSequence(s2);

    EXPECT_CALL(*this, update_callback()).Times(1);

    server_->start();

    // allow time for the sync timeout
    sleep(3);
    wait_for_event_thread();

    // check the time, we give it a finite range just in case of some OS jitter
    EXPECT_TRUE(IsBetweenInclusive(server_->time(), 87840, 87841));
    EXPECT_EQ(server_->day_of_week(), BroadcastTimeDefs::FRIDAY);
    EXPECT_EQ(server_->day_of_year(), 1);
};

TEST_F(BroadcastTimeServerTest, DateRolloverForwardOnTopOfSync)
{
    ::testing::Sequence s1, s2, s3;

    // set events
    expect_packet(":X195B422AN0101000001001739;").InSequence(s1);
    expect_packet(":X195B422AN0101000001002101;").InSequence(s1);
    expect_packet(":X195B422AN01010000010037B2;").InSequence(s1);
    expect_packet(":X195B422AN01010000010047D0;").InSequence(s1);
    EXPECT_CALL(*this, update_callback()).Times(4);

    server_->set_time(23, 57);
    server_->set_date(1, 1);
    server_->set_year(1970);
    server_->set_rate(2000);
    wait_for_event_thread();

    // start
    expect_packet(":X195B422AN010100000100F002;").InSequence(s2);

    // date rollover
    expect_packet(":X195B422AN010100000100F003;").InSequence(s3);
    expect_packet(":X195B422AN0101000001000000;").InSequence(s3);

    // sync seqeunce
    expect_packet(":X1954422AN010100000100F002;").InSequence(s2);
    expect_packet(":X1954422AN01010000010047D0;").InSequence(s2);
    expect_packet(":X1954422AN01010000010037B2;").InSequence(s2);
    expect_packet(":X1954422AN0101000001002102;").InSequence(s2);
    expect_packet(":X1954422AN0101000001000016;").InSequence(s2);
    expect_packet(":X195B422AN0101000001000017;").InSequence(s2);

    // date rollover continued
    expect_packet(":X195B422AN01010000010037B2;").InSequence(s3);
    expect_packet(":X195B422AN0101000001002102;").InSequence(s3);

    // callbacks on clock update
    EXPECT_CALL(*this, update_callback()).Times(1);

    server_->start();

    // allow time for the sync timeout
    sleep(3);
    wait_for_event_thread();

    // check the time, we give it a finite range just in case of some OS jitter
    EXPECT_TRUE(IsBetweenInclusive(server_->time(), 87720, 87721));
    EXPECT_EQ(server_->day_of_week(), BroadcastTimeDefs::FRIDAY);
    EXPECT_EQ(server_->day_of_year(), 1);
};

} // namespace openlcb
