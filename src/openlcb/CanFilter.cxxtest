#include "utils/test_main.hxx"
#include "openlcb/CanFilter.hxx"

namespace openlcb {

class CanFilterTest : public ::testing::Test {
protected:
    CanFilter filter;

    // Helper to create a fake CanHubData
    struct Context {
        CanHubData data;

        Context() {}
    };

    void setup_frame(CanHubData* d, uint32_t can_id, uintptr_t source_port, const std::vector<uint8_t>& payload = {}) {
        d->mutable_frame()->can_id = can_id | CAN_EFF_FLAG;
        d->mutable_frame()->can_dlc = payload.size();
        if (payload.size() > 8) {
             d->mutable_frame()->can_dlc = 8;
        }
        for (size_t i = 0; i < d->mutable_frame()->can_dlc; ++i) {
            d->mutable_frame()->data[i] = payload[i];
        }
        d->skipMember_ = reinterpret_cast<FlowInterface<Buffer<CanHubData>>*>(source_port);
    }
};

TEST_F(CanFilterTest, BroadcastControlFrame) {
    Context ctx;
    // CONTROL_MSG (0).
    uint32_t id = 0x10000000;

    setup_frame(&ctx.data, id, 100);

    filter.prepare_packet(&ctx.data);

    EXPECT_TRUE(filter.is_matching(200));
    EXPECT_TRUE(filter.is_matching(300));
    EXPECT_FALSE(filter.is_matching(100)); // Source filtering
}

TEST_F(CanFilterTest, BroadcastGlobalMessage) {
    Context ctx;
    // GLOBAL_ADDRESSED (1), MTI_ADDRESS_MASK = 0.

    uint32_t id = 0;
    CanDefs::set_fields(&id, 0x123, Defs::MTI_EVENT_REPORT, CanDefs::GLOBAL_ADDRESSED, CanDefs::NMRANET_MSG, CanDefs::NORMAL_PRIORITY);

    setup_frame(&ctx.data, id, 100);
    filter.prepare_packet(&ctx.data);

    EXPECT_TRUE(filter.is_matching(200));
    EXPECT_FALSE(filter.is_matching(100));
}

TEST_F(CanFilterTest, UnicastUnknownDestination) {
    Context ctx;
    // Unicast message: Address Present.
    // Destination 0x456. In payload.
    // 0x456 -> Hi: 0x4, Lo: 0x56.
    // Payload: 0x04, 0x56.

    uint32_t id = 0;
    CanDefs::set_fields(&id, 0x123, Defs::MTI_VERIFY_NODE_ID_ADDRESSED, CanDefs::GLOBAL_ADDRESSED, CanDefs::NMRANET_MSG, CanDefs::NORMAL_PRIORITY);

    setup_frame(&ctx.data, id, 100, {0x04, 0x56});
    filter.prepare_packet(&ctx.data);

    // Destination 0x456 is unknown -> Flood.
    EXPECT_TRUE(filter.is_matching(200));
    EXPECT_FALSE(filter.is_matching(100));
}

TEST_F(CanFilterTest, SourceLearningAndUnicast) {
    Context ctx1, ctx2;

    // Packet 1: From 0x456 (on port 200) to Global.
    uint32_t id1 = 0;
    CanDefs::set_fields(&id1, 0x456, Defs::MTI_EVENT_REPORT, CanDefs::GLOBAL_ADDRESSED, CanDefs::NMRANET_MSG, CanDefs::NORMAL_PRIORITY);
    setup_frame(&ctx1.data, id1, 200);

    filter.prepare_packet(&ctx1.data);
    // Should have learned 0x456 -> 200.

    // Packet 2: From 0x123 (on port 100) to 0x456.
    // Addressed message. Dest 0x456 in payload.
    uint32_t id2 = 0;
    CanDefs::set_fields(&id2, 0x123, Defs::MTI_VERIFY_NODE_ID_ADDRESSED, CanDefs::GLOBAL_ADDRESSED, CanDefs::NMRANET_MSG, CanDefs::NORMAL_PRIORITY);
    setup_frame(&ctx2.data, id2, 100, {0x04, 0x56});

    filter.prepare_packet(&ctx2.data);

    // Should match port 200 (where 0x456 is).
    EXPECT_TRUE(filter.is_matching(200));
    // Should NOT match port 300.
    EXPECT_FALSE(filter.is_matching(300));
    // Should NOT match source port 100.
    EXPECT_FALSE(filter.is_matching(100));
}

TEST_F(CanFilterTest, DatagramIsUnicast) {
    Context ctx;
    // Datagram (CanFrameType != GLOBAL_ADDRESSED).
    // CanFrameType = DATAGRAM_ONE_FRAME (2).
    // Dest is in ID.

    uint32_t id = 0;
    CanDefs::set_datagram_fields(&id, 0x123, 0x456, CanDefs::DATAGRAM_ONE_FRAME);

    setup_frame(&ctx.data, id, 100);

    // 0x456 is unknown -> Flood.
    filter.prepare_packet(&ctx.data);
    EXPECT_TRUE(filter.is_matching(200));

    // Now learn 0x456 on port 200.
    Context ctxLearn;
    uint32_t idLearn = 0;
    CanDefs::set_fields(&idLearn, 0x456, Defs::MTI_EVENT_REPORT, CanDefs::GLOBAL_ADDRESSED, CanDefs::NMRANET_MSG, CanDefs::NORMAL_PRIORITY);
    setup_frame(&ctxLearn.data, idLearn, 200);
    filter.prepare_packet(&ctxLearn.data);

    // Now send Datagram again to 0x456.
    filter.prepare_packet(&ctx.data);
    EXPECT_TRUE(filter.is_matching(200));
    EXPECT_FALSE(filter.is_matching(300));
}

TEST_F(CanFilterTest, MultiplePortsForAlias) {
    Context ctxLearn1, ctxLearn2, ctxTest;

    // Learn 0x456 on port 200.
    uint32_t idLearn = 0;
    CanDefs::set_fields(&idLearn, 0x456, Defs::MTI_EVENT_REPORT, CanDefs::GLOBAL_ADDRESSED, CanDefs::NMRANET_MSG, CanDefs::NORMAL_PRIORITY);
    setup_frame(&ctxLearn1.data, idLearn, 200);
    filter.prepare_packet(&ctxLearn1.data);

    // Learn 0x456 on port 201.
    setup_frame(&ctxLearn2.data, idLearn, 201);
    filter.prepare_packet(&ctxLearn2.data);

    // Send unicast to 0x456. Dest in payload.
    uint32_t idTest = 0;
    CanDefs::set_fields(&idTest, 0x123, Defs::MTI_VERIFY_NODE_ID_ADDRESSED, CanDefs::GLOBAL_ADDRESSED, CanDefs::NMRANET_MSG, CanDefs::NORMAL_PRIORITY);
    setup_frame(&ctxTest.data, idTest, 100, {0x04, 0x56});

    filter.prepare_packet(&ctxTest.data);

    EXPECT_TRUE(filter.is_matching(200));
    EXPECT_TRUE(filter.is_matching(201));
    EXPECT_FALSE(filter.is_matching(300));
}

} // namespace openlcb
