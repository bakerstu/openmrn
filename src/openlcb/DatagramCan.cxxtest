/** \copyright
 * Copyright (c) 2014, Balazs Racz
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  - Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 *  - Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * \file DatagramCan.cxxtest
 *
 * Unit tests for the datagram parser and formatter flows.
 *
 * @author Balazs Racz
 * @date 25 Jan 2014
 */

#include "utils/async_datagram_test_helper.hxx"
#include "openlcb/DatagramHandlerDefault.hxx"

namespace openlcb
{

class AsyncRawDatagramTest : public AsyncNodeTest
{
protected:
    AsyncRawDatagramTest()
    {
        ifCan_->dispatcher()->register_handler(&handler_, 0x1C48, 0xFFFF);
        ifCan_->add_owned_flow(TEST_CreateCanDatagramParser(ifCan_.get()));
    }
    ~AsyncRawDatagramTest()
    {
        wait();
        ifCan_->dispatcher()->unregister_handler(&handler_, 0x1C48, 0xFFFF);
    }

    StrictMock<MockMessageHandler> handler_;
};

TEST_F(AsyncRawDatagramTest, CreateDestroy)
{
}

TEST_F(AsyncRawDatagramTest, SingleFrameDatagramArrivesWrongTarget)
{
    send_packet(":X1A333555NFF01020304050607;");
}

TEST_F(AsyncRawDatagramTest, MultiFrameDatagramArrivesWrongTarget)
{
    send_packet(":X1B333555NFF01020304050607;");
    send_packet(":X1C333555NFF01020304050607;");
    send_packet(":X1C333555NFF01020304050607;");
    send_packet(":X1D333555NFF01020304050607;");
}

TEST_F(AsyncRawDatagramTest, SingleFrameDatagramArrivesRightTarget)
{
    EXPECT_CALL(
        handler_,
        handle_message(
            Pointee(AllOf(Field(&GenMessage::mti, Defs::MTI_DATAGRAM),
                          Field(&GenMessage::dstNode, node_),
                          // Field(&GenMessage::payload, NotNull()),
                          Field(&GenMessage::payload,
                                IsBufferValue(0xFF01020304050607ULL)) //,
                          )),
            _));
    send_packet(":X1A22A555NFF01020304050607;");
}

TEST_F(AsyncRawDatagramTest, MultiFrameDatagramArrivesRightTarget)
{
    EXPECT_CALL(
        handler_,
        handle_message(
            Pointee(AllOf(Field(&GenMessage::mti, Defs::MTI_DATAGRAM),
                          Field(&GenMessage::dstNode, node_),
                          // Field(&GenMessage::payload, NotNull()),
                          Field(&GenMessage::payload,
                                IsBufferValueString(
                                    "01234567112345672123456731234567")) //,
                          )),
            _));
    send_packet(":X1B22A555N3031323334353637;");
    send_packet(":X1C22A555N3131323334353637;");
    send_packet(":X1C22A555N3231323334353637;");
    send_packet(":X1D22A555N3331323334353637;");
}

TEST_F(AsyncRawDatagramTest, OutOfOrderRestart)
{
    send_packet(":X1B22A555N3031323334353637;");
    send_packet(":X1C22A555N3131323334353637;");
    send_packet(":X1C22A555N3231323334353637;");

    // Another start packet -> rejection.
    send_packet_and_expect_response(":X1B22A555N3031323334353637;",
                                    ":X19A4822AN05552040;");

    // Now the finish packet will die as well.
    send_packet_and_expect_response(":X1D22A555N3331323334353637;",
                                    ":X19A4822AN05552040;");
}

TEST_F(AsyncRawDatagramTest, MultiFrameDatagramThenStartMiddle)
{
    EXPECT_CALL(
        handler_,
        handle_message(
            Pointee(AllOf(Field(&GenMessage::mti, Defs::MTI_DATAGRAM),
                          Field(&GenMessage::dstNode, node_),
                          // Field(&GenMessage::payload, NotNull()),
                          Field(&GenMessage::payload,
                                IsBufferValueString(
                                    "01234567112345672123456731234567")) //,
                          )),
            _));
    send_packet(":X1B22A555N3031323334353637;");
    send_packet(":X1C22A555N3131323334353637;");
    send_packet(":X1C22A555N3231323334353637;");
    send_packet(":X1D22A555N3331323334353637;");
    // Datagram should be complete here.

    // A finish packet out of the blue.
    send_packet_and_expect_response(":X1D22A555N3331323334353637;",
                                    ":X19A4822AN05552040;");

    // A middle packet out of the blue.
    send_packet_and_expect_response(":X1C22A555N3331323334353637;",
                                    ":X19A4822AN05552040;");
}

/*
::std::ostream& operator<<(::std::ostream& o, const Buffer* b)
{
    o << "Buffer(";
    if (!b)
    {
        o << "NULL)";
    }
    else
    {
        o << "used " << b->used() << " data ";
        const uint8_t* bytes = static_cast<const uint8_t*>(b->start());
        for (unsigned i = 0; i < b->used(); ++i)
        {
            o << StringPrintf("%02x ", bytes[i]);
        }
        o << ")";
    }
    return o;
    }*/

::std::ostream &operator<<(::std::ostream &o, const NodeHandle &h)
{
    o << StringPrintf("Handle(%012llx, %03x)", h.id, h.alias);
    return o;
}

::std::ostream &operator<<(::std::ostream &o, const GenMessage &m)
{
    o << "a GenMessage"
      << " of MTI " << StringPrintf("%04x", m.mti) << " from " << m.src
      << " to " << m.dst << " to node " << m.dstNode << " with payload "
      << m.payload;
    return o;
}

TEST_F(AsyncRawDatagramTest, MaxSizeDatagram)
{
    send_packet(":X1B22A555N3031323334353637;"); // 8
    for (int i = 0; i < 7; i++)
    { // +7*
        send_packet(StringPrintf(":X1C22A555N3%d31323334353637;", i + 1)); // 8
    }
    EXPECT_CALL(
        handler_,
        handle_message(
            Pointee(AllOf(Field(&GenMessage::mti, Defs::MTI_DATAGRAM),
                          Field(&GenMessage::dstNode, node_),
                          // Field(&GenMessage::payload, NotNull()),
                          Field(&GenMessage::payload,
                                IsBufferValueString("01234567112345672123456731"
                                                    "23456741234567512345676123"
                                                    "45677123456781234567")) //,
                          )),
            _));
    send_packet(":X1D22A555N3831323334353637;"); // 8
}

TEST_F(AsyncRawDatagramTest, TooLongDatagram)
{
    send_packet(":X1B22A555N3031323334353637;"); // 8
    for (int i = 0; i < 8; i++)
    { // +8*
        send_packet(StringPrintf(":X1C22A555N3%d31323334353637;", i + 1)); // 8
    }
    send_packet_and_expect_response(
        ":X1C22A555N3031323334353637;",
        ":X19A4822AN05551000;"); // Datagram rejected permanent error
}

TEST_F(AsyncRawDatagramTest, TooLongDatagram2)
{
    send_packet(":X1B22A555N3031323334353637;"); // 8
    for (int i = 0; i < 8; i++)
    { // +8*
        send_packet(StringPrintf(":X1C22A555N3%d31323334353637;", i + 1)); // 8
    }
    send_packet_and_expect_response(
        ":X1D22A555N3031323334353637;",
        ":X19A4822AN05551000;"); // Datagram rejected permanent error
}

TEST_F(AsyncRawDatagramTest, MultiFrameDatagramArrivesInterleavedSingle)
{
    EXPECT_CALL(
        handler_,
        handle_message(
            Pointee(AllOf(Field(&GenMessage::mti, Defs::MTI_DATAGRAM),
                          Field(&GenMessage::dstNode, node_),
                          // Field(&GenMessage::payload, NotNull()),
                          Field(&GenMessage::payload,
                                IsBufferValueString(
                                    "01234567112345672123456731234567")) //,
                          )),
            _));
    EXPECT_CALL(
        handler_,
        handle_message(
            Pointee(AllOf(Field(&GenMessage::mti, Defs::MTI_DATAGRAM),
                          Field(&GenMessage::dstNode, node_),
                          // Field(&GenMessage::payload, NotNull()),
                          Field(&GenMessage::payload,
                                IsBufferValueString("01234")) //,
                          )),
            _));
    send_packet(":X1B22A555N3031323334353637;");
    send_packet(":X1C22A555N3131323334353637;");
    send_packet(":X1A22A555N3031323334;"); // A single-frame datagram here.
    send_packet(":X1C22A555N3231323334353637;");
    send_packet(":X1D22A555N3331323334353637;");
}

TEST_F(AsyncRawDatagramTest, MultiFrameIntermixed)
{
    send_packet(":X1B22A555N3031323334353637;");
    send_packet(":X1C22A555N3131323334353637;");
    send_packet(":X1C22A555N3231323334353637;");
    EXPECT_CALL(
        handler_,
        handle_message(
            Pointee(AllOf(
                Field(&GenMessage::mti, Defs::MTI_DATAGRAM),
                Field(&GenMessage::dstNode, node_),
                Field(&GenMessage::src, Field(&NodeHandle::alias, 0x577)),
                // Field(&GenMessage::payload, NotNull()),
                Field(&GenMessage::payload,
                      IsBufferValueString("0123456711234567")) //,
                )),
            _));
    send_packet(":X1B22A577N3031323334353637;");
    EXPECT_CALL(
        handler_,
        handle_message(
            Pointee(AllOf(
                Field(&GenMessage::mti, Defs::MTI_DATAGRAM),
                Field(&GenMessage::dstNode, node_),
                Field(&GenMessage::src, Field(&NodeHandle::alias, 0x555)),
                // Field(&GenMessage::payload, NotNull()),
                Field(
                    &GenMessage::payload,
                    IsBufferValueString("01234567112345672123456731234567")) //,
                )),
            _));
    send_packet(":X1D22A555N3331323334353637;");
    send_packet(":X1D22A577N3131323334353637;");
}

TEST_F(AsyncRawDatagramTest, MultiFrameIntermixedDst)
{
    EXPECT_CALL(canBus_, mwrite(":X1910022BN02010D000004;")).Times(1);
    ifCan_->local_aliases()->add(TEST_NODE_ID + 1, 0x22B);
    DefaultNode other_node(ifCan_.get(), TEST_NODE_ID + 1);

    send_packet(":X1B22A555N3031323334353637;");
    send_packet(":X1C22A555N3131323334353637;");
    send_packet(":X1C22A555N3231323334353637;");
    EXPECT_CALL(
        handler_,
        handle_message(
            Pointee(AllOf(
                Field(&GenMessage::mti, Defs::MTI_DATAGRAM),
                Field(&GenMessage::dstNode, &other_node),
                Field(&GenMessage::src, Field(&NodeHandle::alias, 0x555)),
                // Field(&GenMessage::payload, NotNull()),
                Field(&GenMessage::payload,
                      IsBufferValueString("0123456711234567")) //,
                )),
            _));
    send_packet(":X1B22B555N3031323334353637;");
    EXPECT_CALL(
        handler_,
        handle_message(
            Pointee(AllOf(
                Field(&GenMessage::mti, Defs::MTI_DATAGRAM),
                Field(&GenMessage::dstNode, node_),
                Field(&GenMessage::src, Field(&NodeHandle::alias, 0x555)),
                // Field(&GenMessage::payload, NotNull()),
                Field(
                    &GenMessage::payload,
                    IsBufferValueString("01234567112345672123456731234567")) //,
                )),
            _));
    send_packet(":X1D22A555N3331323334353637;");
    send_packet(":X1D22B555N3131323334353637;");
    wait();
}

class MockDatagramHandler : public DatagramHandlerFlow
{
public:
    MockDatagramHandler() : DatagramHandlerFlow(&g_service)
    {
    }

    MOCK_METHOD1(handle_datagram, void(IncomingDatagram *d));

    Action entry() OVERRIDE
    {
        handle_datagram(message()->data());
        return release_and_exit();
    }
};

TEST_F(AsyncDatagramTest, DispatchTest)
{
    StrictMock<MockDatagramHandler> dg;
    datagram_support_.registry()->insert(nullptr, 0x30, &dg);
    EXPECT_CALL(
        dg, handle_datagram(Pointee(AllOf(
                Field(&IncomingDatagram::src, Field(&NodeHandle::alias, 0x555)),
                Field(&IncomingDatagram::dst, node_),
                // Field(&IncomingDatagram::payload, NotNull()),
                Field(&IncomingDatagram::payload,
                      IsBufferValueString("01234567")) //,
                ))));
    send_packet(":X1A22A555N3031323334353637;");
    wait();
    usleep(3000);
}

DatagramPayload string_to_buffer(const string &value)
{
    return value;
}

TEST_F(AsyncDatagramTest, OutgoingTestSmall)
{
    print_all_packets();
    DatagramClient *c = datagram_support_.client_allocator()->next_blocking();
    NodeHandle h{0, 0x77C};
    expect_packet(":X1A77C22AN30313233343536;");
    auto *b = ifCan_->dispatcher()->alloc();
    b->data()->reset(Defs::MTI_DATAGRAM, node_->node_id(), h,
                     string_to_buffer("0123456"));
    b->set_done(get_notifiable());
    c->write_datagram(b);
    wait();
    wait();
    send_packet(":X19A2877CN022A00;"); // Received OK
    wait_for_notification();
    // Releases client.
    datagram_support_.client_allocator()->insert(c);
}

TEST_F(AsyncDatagramTest, DoubleReply)
{
    print_all_packets();
    DatagramClient *c = datagram_support_.client_allocator()->next_blocking();
    NodeHandle h{0, 0x77C};
    expect_packet(":X1A77C22AN30313233343536;");
    auto *b = ifCan_->dispatcher()->alloc();
    b->data()->reset(Defs::MTI_DATAGRAM, node_->node_id(), h,
                     string_to_buffer("0123456"));
    b->set_done(get_notifiable());
    c->write_datagram(b);
    wait();
    wait();
    send_packet(":X19A2877CN022A00;"); // Received OK
    send_packet(":X19A2877CN022A00;"); // Received OK dup
    wait_for_notification();
    // Releases client.
    send_packet(":X19A2877CN022A00;"); // Received OK dup
    wait();
    datagram_support_.client_allocator()->insert(c);
}

TEST_F(AsyncDatagramTest, OutgoingTestOneFull)
{
    DatagramClient *c = datagram_support_.client_allocator()->next_blocking();
    NodeHandle h{0, 0x77C};
    expect_packet(":X1A77C22AN3031323334353637;");
    auto *b = ifCan_->dispatcher()->alloc();
    b->set_done(get_notifiable());
    b->data()->reset(Defs::MTI_DATAGRAM, node_->node_id(), h,
                     string_to_buffer("01234567"));
    c->write_datagram(b);

    wait();
    send_packet(":X19A2877CN022A00;"); // Received OK
    wait_for_notification();
}

TEST_F(AsyncDatagramTest, OutgoingTestBeginEnd)
{
    DatagramClient *c = datagram_support_.client_allocator()->next_blocking();
    NodeHandle h{0, 0x77C};
    expect_packet(":X1B77C22AN3031323334353637;");
    expect_packet(":X1D77C22AN3839303132333435;");
    auto *b = ifCan_->dispatcher()->alloc();
    b->set_done(get_notifiable());
    b->data()->reset(Defs::MTI_DATAGRAM, node_->node_id(), h,
                     string_to_buffer("0123456789012345"));
    c->write_datagram(b);

    wait();
    send_packet(":X19A2877CN022A00;"); // Received OK
    wait_for_notification();
}

TEST_F(AsyncDatagramTest, OutgoingTestMiddle)
{
    DatagramClient *c = datagram_support_.client_allocator()->next_blocking();
    NodeHandle h{0, 0x77C};
    expect_packet(":X1B77C22AN3031323334353637;");
    expect_packet(":X1C77C22AN3839303132333435;");
    expect_packet(":X1D77C22AN3031323334353637;");
    auto *b = ifCan_->dispatcher()->alloc();
    b->set_done(get_notifiable());
    b->data()->reset(Defs::MTI_DATAGRAM, node_->node_id(), h,
                     string_to_buffer("012345678901234501234567"));
    c->write_datagram(b);

    wait();
    send_packet(":X19A2877CN022A00;"); // Received OK
    wait_for_notification();
}

TEST_F(AsyncDatagramTest, ResponseOK)
{
    DatagramClient *c = datagram_support_.client_allocator()->next_blocking();
    NodeHandle h{0, 0x77C};
    expect_packet(":X1A77C22AN30313233343536;");
    auto *b = ifCan_->dispatcher()->alloc();
    b->set_done(get_notifiable());
    b->data()->reset(Defs::MTI_DATAGRAM, node_->node_id(), h,
                     string_to_buffer("0123456"));
    c->write_datagram(b);

    wait();
    send_packet(":X19A2877CN022A00;"); // Received OK
    wait_for_notification();
    EXPECT_EQ((unsigned)DatagramClient::OPERATION_SUCCESS, c->result());
}

TEST_F(AsyncDatagramTest, SendByAddressCacheHit)
{
    DatagramClient *c = datagram_support_.client_allocator()->next_blocking();
    NodeHandle h{TEST_NODE_ID + 3, 0};
    ifCan_->remote_aliases()->add(h.id, 0x77C);
    expect_packet(":X1A77C22AN30313233343536;");
    auto *b = ifCan_->dispatcher()->alloc();
    b->set_done(get_notifiable());
    b->data()->reset(Defs::MTI_DATAGRAM, node_->node_id(), h,
                     string_to_buffer("0123456"));
    c->write_datagram(b);
    wait();
    send_packet(":X19A2877CN022A00;"); // Received OK
    wait_for_notification();
    EXPECT_EQ((unsigned)DatagramClient::OPERATION_SUCCESS, c->result());
}

TEST_F(AsyncDatagramTest, SendByAddressCacheMiss)
{
    DatagramClient *c = datagram_support_.client_allocator()->next_blocking();
    NodeHandle h{0x050101FFFFDDULL, 0};
    expect_packet(":X1070222AN050101FFFFDD;"); // AME frame
    auto *b = ifCan_->dispatcher()->alloc();
    b->set_done(get_notifiable());
    b->data()->reset(Defs::MTI_DATAGRAM, node_->node_id(), h,
                     string_to_buffer("0123456"));
    c->write_datagram(b);

    wait();
    send_packet_and_expect_response(":X10701210N050101FFFFDD;", // AMD frame
                                    ":X1A21022AN30313233343536;");
    send_packet(":X19A28210N022A00;"); // Received OK
    wait_for_notification();
    EXPECT_EQ((unsigned)DatagramClient::OPERATION_SUCCESS, c->result());
    // Checks that the new lookup value got into the cache.
    EXPECT_EQ(0x210U, ifCan_->remote_aliases()->lookup(h.id));
}

TEST_F(AsyncDatagramTest, ResponseOKWithCode)
{
    DatagramClient *c = datagram_support_.client_allocator()->next_blocking();
    NodeHandle h{0, 0x77C};
    expect_packet(":X1A77C22AN30313233343536;");
    auto *b = ifCan_->dispatcher()->alloc();
    b->set_done(get_notifiable());
    b->data()->reset(Defs::MTI_DATAGRAM, node_->node_id(), h,
                     string_to_buffer("0123456"));
    c->write_datagram(b);

    wait();
    send_packet(":X19A2877CN022AA5;"); // Received OK
    wait_for_notification();
    EXPECT_EQ((unsigned)DatagramClient::OPERATION_SUCCESS |
                  (0xA5 << DatagramClient::RESPONSE_FLAGS_SHIFT),
              c->result());
}

TEST_F(AsyncDatagramTest, ResponseOKPendingReply)
{
    DatagramClient *c = datagram_support_.client_allocator()->next_blocking();
    NodeHandle h{0, 0x77C};
    expect_packet(":X1A77C22AN30313233343536;");
    auto *b = ifCan_->dispatcher()->alloc();
    b->set_done(get_notifiable());
    b->data()->reset(Defs::MTI_DATAGRAM, node_->node_id(), h,
                     string_to_buffer("0123456"));
    c->write_datagram(b);

    wait();
    send_packet(":X19A2877CN022A80;"); // Received OK
    wait_for_notification();
    EXPECT_TRUE(c->result() & (DatagramClient::OK_REPLY_PENDING));
}

TEST_F(AsyncDatagramTest, Rejected)
{
    DatagramClient *c = datagram_support_.client_allocator()->next_blocking();
    NodeHandle h{0, 0x77C};
    expect_packet(":X1A77C22AN30313233343536;");
    auto *b = ifCan_->dispatcher()->alloc();
    b->set_done(get_notifiable());
    b->data()->reset(Defs::MTI_DATAGRAM, node_->node_id(), h,
                     string_to_buffer("0123456"));
    c->write_datagram(b);

    wait();
    send_packet(":X19A4877CN022A55AA;"); // Datagram rejected.
    wait_for_notification();
    EXPECT_EQ(0x55AAU, c->result());
}

TEST_F(AsyncDatagramTest, Timeout)
{
    ScopedOverride ov(&DATAGRAM_RESPONSE_TIMEOUT_NSEC, MSEC_TO_NSEC(20));
    DatagramClient *c = datagram_support_.client_allocator()->next_blocking();
    NodeHandle h{0, 0x77C};
    expect_packet(":X1A77C22AN30313233343536;");
    auto *b = ifCan_->dispatcher()->alloc();
    b->set_done(get_notifiable());
    b->data()->reset(Defs::MTI_DATAGRAM, node_->node_id(), h,
                     string_to_buffer("0123456"));
    c->write_datagram(b);

    wait();
    wait_for_notification();
    EXPECT_EQ(
        (unsigned)(DatagramClient::TIMEOUT | DatagramClient::PERMANENT_ERROR),
        c->result());
}

TEST_F(AsyncDatagramTest, RejectedNoData)
{
    DatagramClient *c = datagram_support_.client_allocator()->next_blocking();
    NodeHandle h{0, 0x77C};
    expect_packet(":X1A77C22AN30313233343536;");
    auto *b = ifCan_->dispatcher()->alloc();
    b->set_done(get_notifiable());
    b->data()->reset(Defs::MTI_DATAGRAM, node_->node_id(), h,
                     string_to_buffer("0123456"));
    c->write_datagram(b);

    wait();
    send_packet(":X19A4877CN022A;"); // Datagram rejected.
    wait_for_notification();
    EXPECT_TRUE(DatagramClient::PERMANENT_ERROR & c->result());
}

TEST_F(AsyncDatagramTest, OptionalInteractionRejectedNoPayload)
{
    DatagramClient *c = datagram_support_.client_allocator()->next_blocking();
    NodeHandle h{0, 0x77C};
    expect_packet(":X1A77C22AN30313233343536;");
    auto *b = ifCan_->dispatcher()->alloc();
    b->set_done(get_notifiable());
    b->data()->reset(Defs::MTI_DATAGRAM, node_->node_id(), h,
                     string_to_buffer("0123456"));
    c->write_datagram(b);

    wait();
    send_packet(":X1906877CN022A5A;"); // OIR, payload invalid
    wait_for_notification();
    EXPECT_EQ((unsigned)DatagramClient::PERMANENT_ERROR, c->result());
}

TEST_F(AsyncDatagramTest, OptionalInteractionRejectedWrongMTI)
{
    ScopedOverride ov(&DATAGRAM_RESPONSE_TIMEOUT_NSEC, MSEC_TO_NSEC(20));
    DatagramClient *c = datagram_support_.client_allocator()->next_blocking();
    NodeHandle h{0, 0x77C};
    expect_packet(":X1A77C22AN30313233343536;");
    auto *b = ifCan_->dispatcher()->alloc();
    b->set_done(get_notifiable());
    b->data()->reset(Defs::MTI_DATAGRAM, node_->node_id(), h,
                     string_to_buffer("0123456"));
    c->write_datagram(b);

    wait();
    send_packet(
        ":X1906877CN022A55AA0991;"); // OIR, payload with a different MTI
    wait_for_notification();
    // Timeout means the OIR was ignored.
    EXPECT_EQ(
        (unsigned)(DatagramClient::TIMEOUT | DatagramClient::PERMANENT_ERROR),
        c->result());
}

TEST_F(AsyncDatagramTest, OptionalInteractionRejectedCorrectMTI)
{
    ScopedOverride ov(&DATAGRAM_RESPONSE_TIMEOUT_NSEC, MSEC_TO_NSEC(20));
    DatagramClient *c = datagram_support_.client_allocator()->next_blocking();
    NodeHandle h{0, 0x77C};
    expect_packet(":X1A77C22AN30313233343536;");
    auto *b = ifCan_->dispatcher()->alloc();
    b->set_done(get_notifiable());
    b->data()->reset(Defs::MTI_DATAGRAM, node_->node_id(), h,
                     string_to_buffer("0123456"));
    c->write_datagram(b);

    wait();
    send_packet(":X1906877CN022A55AA1C48;"); // OIR, payload with correct MTI
    wait_for_notification();
    EXPECT_EQ(0x55AAU, c->result());
}

TEST_F(AsyncDatagramTest, OptionalInteractionRejectedMustHaveError)
{
    ScopedOverride ov(&DATAGRAM_RESPONSE_TIMEOUT_NSEC, MSEC_TO_NSEC(20));
    DatagramClient *c = datagram_support_.client_allocator()->next_blocking();
    NodeHandle h{0, 0x77C};
    expect_packet(":X1A77C22AN30313233343536;");
    auto *b = ifCan_->dispatcher()->alloc();
    b->set_done(get_notifiable());
    b->data()->reset(Defs::MTI_DATAGRAM, node_->node_id(), h,
                     string_to_buffer("0123456"));
    c->write_datagram(b);

    wait();
    send_packet(":X1906877CN022A00AA1C48;"); // OIR, payload with correct MTI
    wait_for_notification();
    EXPECT_EQ(0x10AAU, c->result()); // Added PERMANENT_ERROR
}

TEST_F(AsyncDatagramTest, OptionalInteractionRejectedTemporaryError)
{
    DatagramClient *c = datagram_support_.client_allocator()->next_blocking();
    NodeHandle h{0, 0x77C};
    expect_packet(":X1A77C22AN30313233343536;");
    auto *b = ifCan_->dispatcher()->alloc();
    b->set_done(get_notifiable());
    b->data()->reset(Defs::MTI_DATAGRAM, node_->node_id(), h,
                     string_to_buffer("0123456"));
    c->write_datagram(b);

    wait();
    send_packet(":X1906877CN022A2000;"); // OIR, temporary error
    wait_for_notification();
    EXPECT_EQ((unsigned)DatagramClient::RESEND_OK, c->result());
}

TEST_F(AsyncDatagramTest, TerminateDueToErrorNoPayload)
{
    DatagramClient *c = datagram_support_.client_allocator()->next_blocking();
    NodeHandle h{0, 0x77C};
    expect_packet(":X1A77C22AN30313233343536;");
    auto *b = ifCan_->dispatcher()->alloc();
    b->set_done(get_notifiable());
    b->data()->reset(Defs::MTI_DATAGRAM, node_->node_id(), h,
                     string_to_buffer("0123456"));
    c->write_datagram(b);

    wait();
    send_packet(":X190A877CN022A5A;"); // TDE, payload invalid
    wait_for_notification();
    EXPECT_EQ((unsigned)DatagramClient::PERMANENT_ERROR, c->result());
}

TEST_F(AsyncDatagramTest, TerminateDueToErrorWrongMTI)
{
    ScopedOverride ov(&DATAGRAM_RESPONSE_TIMEOUT_NSEC, MSEC_TO_NSEC(20));
    DatagramClient *c = datagram_support_.client_allocator()->next_blocking();
    NodeHandle h{0, 0x77C};
    expect_packet(":X1A77C22AN30313233343536;");
    auto *b = ifCan_->dispatcher()->alloc();
    b->set_done(get_notifiable());
    b->data()->reset(Defs::MTI_DATAGRAM, node_->node_id(), h,
                     string_to_buffer("0123456"));
    c->write_datagram(b);

    wait();
    send_packet(
        ":X190A877CN022A55AA0991;"); // TDE, payload with a different MTI
    wait_for_notification();
    // Timeout means the TDE was ignored.
    EXPECT_EQ(
        (unsigned)(DatagramClient::TIMEOUT | DatagramClient::PERMANENT_ERROR),
        c->result());
}

TEST_F(AsyncDatagramTest, TerminateDueToErrorCorrectMTI)
{
    ScopedOverride ov(&DATAGRAM_RESPONSE_TIMEOUT_NSEC, MSEC_TO_NSEC(20));
    DatagramClient *c = datagram_support_.client_allocator()->next_blocking();
    NodeHandle h{0, 0x77C};
    expect_packet(":X1A77C22AN30313233343536;");
    auto *b = ifCan_->dispatcher()->alloc();
    b->set_done(get_notifiable());
    b->data()->reset(Defs::MTI_DATAGRAM, node_->node_id(), h,
                     string_to_buffer("0123456"));
    c->write_datagram(b);

    wait();
    send_packet(":X190A877CN022A55AA1C48;"); // TDE, payload with correct MTI
    wait_for_notification();
    EXPECT_EQ(0x55AAU, c->result());
}

TEST_F(AsyncDatagramTest, TerminateDueToErrorMustHaveError)
{
    ScopedOverride ov(&DATAGRAM_RESPONSE_TIMEOUT_NSEC, MSEC_TO_NSEC(20));
    DatagramClient *c = datagram_support_.client_allocator()->next_blocking();
    NodeHandle h{0, 0x77C};
    expect_packet(":X1A77C22AN30313233343536;");
    auto *b = ifCan_->dispatcher()->alloc();
    b->set_done(get_notifiable());
    b->data()->reset(Defs::MTI_DATAGRAM, node_->node_id(), h,
                     string_to_buffer("0123456"));
    c->write_datagram(b);

    wait();
    send_packet(":X190A877CN022A00AA1C48;"); // TDE, payload with correct MTI
    wait_for_notification();
    EXPECT_EQ(0x10AAU, c->result());
}

TEST_F(AsyncDatagramTest, TerminateDueToErrorTemporaryError)
{
    DatagramClient *c = datagram_support_.client_allocator()->next_blocking();
    NodeHandle h{0, 0x77C};
    expect_packet(":X1A77C22AN30313233343536;");
    auto *b = ifCan_->dispatcher()->alloc();
    b->set_done(get_notifiable());
    b->data()->reset(Defs::MTI_DATAGRAM, node_->node_id(), h,
                     string_to_buffer("0123456"));
    c->write_datagram(b);

    wait();
    send_packet(":X190A877CN022A2000;"); // TDE, temporary error
    wait_for_notification();
    EXPECT_EQ((unsigned)DatagramClient::RESEND_OK, c->result());
}

/** Ping-pong is a fake datagram-based service. When it receives a datagram
 * from a particular node, it sends back the datagram to the originating node
 * with a slight difference: a TTL being decremented and the payload being
 * shortened. Two ping-pong datagram handlers can therefore converse with each
 * other after the injection of a single message.
 *
 * Datagram format: id=0x7A, second byte = length, then length number of bytes.
 *
 * The response will be in the same format, with length decreased by one, and
 * the first length - 1 bytes of the incoming payload. A datagram with payload
 * length 0 will not receive a response.
 */
class PingPongHandler : public DefaultDatagramHandler
{
public:
    enum
    {
        DATAGRAM_ID = 0x7A,
    };

    PingPongHandler(DatagramService *if_dg, Node *node)
        : DefaultDatagramHandler(if_dg)
        , processCount_(0)
    {
        dg_service()->registry()->insert(node, DATAGRAM_ID, this);
    }

    ~PingPongHandler()
    {
        /** @TODO(balazs.racz) Remove handler entry from the registry. It would
         * be important to remember the node for that, and need a remove API
         * on the NodeHandlerMap. */
    }

    /// Returns how many datagrams this handler has seen so far.
    int process_count()
    {
        return processCount_;
    }

    Action entry() OVERRIDE
    {
        processCount_++;
        const uint8_t *bytes = reinterpret_cast<const uint8_t *>(
            message()->data()->payload.data());
        size_t len = message()->data()->payload.size();
        HASSERT(len >= 1);
        HASSERT(bytes[0] == DATAGRAM_ID);
        if (len <= 1)
        {
            return respond_reject(DatagramClient::PERMANENT_ERROR);
        }
        if (bytes[1] > 0)
        {
            return respond_ok(DatagramClient::REPLY_PENDING);
        }
        else
        {
            return respond_ok(0);
        }
    }

    virtual Action ok_response_sent()
    {
        const uint8_t *bytes = reinterpret_cast<const uint8_t *>(
            message()->data()->payload.data());
        if (!bytes[1])
        {
            // No response.
            return release_and_exit();
        }

        // We take over the buffer ownership.
        responsePayload_.swap(message()->data()->payload);
        responsePayload_.resize(responsePayload_.size() - 1);
        --responsePayload_[1];

        return allocate_and_call(STATE(client_allocated),
                                 dg_service()->client_allocator());
    }

    Action client_allocated()
    {
        clientFlow_ = full_allocation_result(dg_service()->client_allocator());
        return allocate_and_call(dg_service()->iface()->dispatcher(),
                                 STATE(send_response_datagram));
    }

    Action send_response_datagram()
    {
        auto *b =
            get_allocation_result(dg_service()->iface()->dispatcher());
        b->set_done(b_.reset(this));
        b->data()->reset(Defs::MTI_DATAGRAM, message()->data()->dst->node_id(),
                         message()->data()->src, EMPTY_PAYLOAD);
        b->data()->payload.swap(responsePayload_);
        release();
        clientFlow_->write_datagram(b);
        return wait_and_call(STATE(wait_response_datagram));
    }

    Action wait_response_datagram()
    {
        if (clientFlow_->result() & DatagramClient::OPERATION_PENDING)
        {
            DIE("Unexpected notification from the datagram client.");
        }
        if (!clientFlow_->result() & DatagramClient::OPERATION_SUCCESS)
        {
            LOG(WARNING, "Error sending response datagram for PingPong: %x",
                clientFlow_->result());
        }
        dg_service()->client_allocator()->typed_insert(clientFlow_);
        return release_and_exit();
    }

private:
    int processCount_; //< tracks the number of incoming datagrams
    DatagramPayload responsePayload_;
    DatagramClient *clientFlow_;
    BarrierNotifiable b_;
};

// @TODO(balazs.racz) add a test where a datagram is arriving without
// payload. It should receive a rejection response.

TEST_F(TwoNodeDatagramTest, PingPongTestOne)
{
    print_all_packets();
    setup_other_node(true);
    expect_other_node_lookup();

    PingPongHandler handler_one(&datagram_support_, node_);
    PingPongHandler handler_two(otherNodeDatagram_, otherNode_.get());

    DatagramClient *c = datagram_support_.client_allocator()->next_blocking();
    NodeHandle h{OTHER_NODE_ID, 0};
    DatagramPayload payload;
    payload.resize(4);
    uint8_t *bytes = reinterpret_cast<uint8_t *>(&payload[0]);
    bytes[0] = PingPongHandler::DATAGRAM_ID;
    bytes[1] = 2;
    bytes[2] = 0x30;
    bytes[3] = 0x31;

    expect_packet(":X1A22522AN7A023031;"); // ping
    expect_packet(":X19A28225N022A80;");   // ack OK, reply pending
    expect_packet(":X1A22A225N7A0130;");   // pong
    expect_packet(":X19A2822AN022580;");   // ack OK, reply pending
    expect_packet(":X1A22522AN7A00;");     // ping
    expect_packet(":X19A28225N022A00;");   // ack OK, no reply

    auto *b = ifCan_->dispatcher()->alloc();
    b->set_done(get_notifiable());
    b->data()->reset(Defs::MTI_DATAGRAM, node_->node_id(), h, payload);
    c->write_datagram(b);

    wait_for_notification();
    EXPECT_EQ((unsigned)DatagramClient::OK_REPLY_PENDING |
                  DatagramClient::OPERATION_SUCCESS,
              c->result())
        << StringPrintf("result: %x", c->result());
    wait();
    EXPECT_EQ(2, handler_two.process_count());
    EXPECT_EQ(1, handler_one.process_count());
}

TEST_F(TwoNodeDatagramTest, PingPongTestError)
{
    print_all_packets();
    setup_other_node(true);
    expect_other_node_lookup();

    PingPongHandler handler_one(&datagram_support_, node_);
    PingPongHandler handler_two(otherNodeDatagram_, otherNode_.get());

    DatagramClient *c = datagram_support_.client_allocator()->next_blocking();
    NodeHandle h{OTHER_NODE_ID, 0};
    DatagramPayload payload;
    payload.resize(1);
    uint8_t *bytes = reinterpret_cast<uint8_t *>(&payload[0]);
    bytes[0] = PingPongHandler::DATAGRAM_ID;

    expect_packet(":X1A22522AN7A;");       // ping
    expect_packet(":X19A48225N022A1000;"); // rejected permanent error

    auto *b = ifCan_->dispatcher()->alloc();
    b->set_done(get_notifiable());
    b->data()->reset(Defs::MTI_DATAGRAM, node_->node_id(), h, payload);
    c->write_datagram(b);

    wait_for_notification();
    EXPECT_EQ((unsigned)DatagramClient::PERMANENT_ERROR, c->result())
        << StringPrintf("result: %x", c->result());
    wait();
    EXPECT_EQ(1, handler_two.process_count());
    EXPECT_EQ(0, handler_one.process_count());
}

/// @TODO(balazs.racz): turn this into a TEST_P
TEST_F(TwoNodeDatagramTest, PingPongTestLoopback)
{
    print_all_packets();
    setup_other_node(false);
    // expect_other_node_lookup();

    PingPongHandler handler_one(&datagram_support_, node_);
    PingPongHandler handler_two(otherNodeDatagram_, otherNode_.get());

    DatagramClient *c = datagram_support_.client_allocator()->next_blocking();
    NodeHandle h{OTHER_NODE_ID, 0};
    DatagramPayload payload;
    payload.resize(4);
    uint8_t *bytes = reinterpret_cast<uint8_t *>(&payload[0]);
    bytes[0] = PingPongHandler::DATAGRAM_ID;
    bytes[1] = 2;
    bytes[2] = 0x30;
    bytes[3] = 0x31;

    auto *b = ifCan_->dispatcher()->alloc();
    b->set_done(get_notifiable());
    b->data()->reset(Defs::MTI_DATAGRAM, node_->node_id(), h, payload);
    c->write_datagram(b);

    wait_for_notification();
    EXPECT_EQ((unsigned)DatagramClient::OK_REPLY_PENDING |
                  DatagramClient::OPERATION_SUCCESS,
              c->result())
        << StringPrintf("result: %x", c->result());
    wait();
    EXPECT_EQ(2, handler_two.process_count());
    EXPECT_EQ(1, handler_one.process_count());
}

TEST_F(TwoNodeDatagramTest, PingPongLoopbackError)
{
    print_all_packets();
    setup_other_node(false);
    // expect_other_node_lookup();

    PingPongHandler handler_one(&datagram_support_, node_);
    PingPongHandler handler_two(otherNodeDatagram_, otherNode_.get());

    DatagramClient *c = datagram_support_.client_allocator()->next_blocking();
    NodeHandle h{OTHER_NODE_ID, 0};
    DatagramPayload payload;
    payload.resize(1);
    uint8_t *bytes = reinterpret_cast<uint8_t *>(&payload[0]);
    bytes[0] = PingPongHandler::DATAGRAM_ID;

    auto *b = ifCan_->dispatcher()->alloc();
    b->set_done(get_notifiable());
    b->data()->reset(Defs::MTI_DATAGRAM, node_->node_id(), h, payload);
    c->write_datagram(b);

    wait_for_notification();
    EXPECT_EQ((unsigned)DatagramClient::PERMANENT_ERROR, c->result())
        << StringPrintf("result: %x", c->result());
    wait();
    EXPECT_EQ(1, handler_two.process_count());
    EXPECT_EQ(0, handler_one.process_count());
}

TEST_F(TwoNodeDatagramTest, NoDestinationHandler)
{
    print_all_packets();
    setup_other_node(true);
    expect_other_node_lookup();

    DatagramClient *c = datagram_support_.client_allocator()->next_blocking();
    NodeHandle h{OTHER_NODE_ID, 0};
    DatagramPayload payload;
    payload.resize(4);
    uint8_t *bytes = reinterpret_cast<uint8_t *>(&payload[0]);
    bytes[0] = PingPongHandler::DATAGRAM_ID;
    bytes[1] = 2;
    bytes[2] = 0x30;
    bytes[3] = 0x31;

    expect_packet(":X1A22522AN7A023031;"); // ping
    expect_packet(":X19A48225N022A1000;"); // rejected, permanent error

    auto *b = ifCan_->dispatcher()->alloc();
    b->set_done(get_notifiable());
    b->data()->reset(Defs::MTI_DATAGRAM, node_->node_id(), h, payload);
    c->write_datagram(b);

    wait_for_notification();
    EXPECT_EQ((unsigned)DatagramClient::PERMANENT_ERROR, c->result())
        << StringPrintf("result: %x", c->result());
    wait();
}

} // namespace openlcb
