/** \copyright
 * Copyright (c) 2014, Balazs Racz
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are  permitted provided that the following conditions are met:
 *
 *  - Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 *  - Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * \file Stm32DCCDecoder.hxx
 *
 * Device driver module for STM32 to decode a DCC track signal.
 *
 * @author Balazs Racz
 * @date 29 Nov 2014
 */

#include "Stm32Gpio.hxx" // for pin definitions
#include "freertos_drivers/common/DccDecoder.hxx"
#include "FreeRTOSConfig.h"

#include "stm32f_hal_conf.hxx"

typedef DummyPin PIN_RailcomCutout;

/**
  Helper module for decoding a DCC signal on an STM32 class microcontroller.
 
  Usage: Define a structure `HW` declaring certain constants around your timer
  usage.

  Example hardware definitions:

struct DCCDecode
{
    static const auto TIMER_BASE = WTIMER4_BASE;
    static const auto TIMER_PERIPH = SYSCTL_PERIPH_WTIMER4;
    static const auto TIMER_INTERRUPT = INT_WTIMER4A;
    static const auto TIMER = TIMER_A;
    static const auto CFG_CAP_TIME_UP =
        TIMER_CFG_SPLIT_PAIR | TIMER_CFG_A_CAP_TIME_UP | TIMER_CFG_B_ONE_SHOT;
    // Interrupt bits.
    static const auto TIMER_CAP_EVENT = TIMER_CAPA_EVENT;
    static const auto TIMER_TIM_TIMEOUT = TIMER_TIMA_TIMEOUT;

    static const auto OS_INTERRUPT = INT_WTIMER4B;
    DECL_PIN(NRZPIN, D, 4);
    static const auto NRZPIN_CONFIG = GPIO_PD4_WT4CCP0;

    static const uint32_t TIMER_MAX_VALUE = 0x8000000UL;

    static const int Q_SIZE = 16;

};
 */


template <class HW> class Stm32DccTimerModule
{
public:
    /// Exports the input pin to the driver on the module interface.
    using NRZ_Pin = typename HW::NRZ_Pin;

    // These constants are exported from HW to the driver.

    /// This is the counter from which the timer starts counting down. When the
    /// timer overflows, it starts from this value.
    static constexpr uint32_t TIMER_MAX_VALUE = HW::TIMER_MAX_VALUE;
    /// After how many timer counts we should take one sample for occupancy
    /// feedback.
    static constexpr uint32_t SAMPLE_PERIOD_CLOCKS = HW::SAMPLE_PERIOD_TICKS;
    /// Length of the device queue.
    static constexpr unsigned Q_SIZE = HW::Q_SIZE;

    /// We setthe timer prescaler to go at one tick per usec.
    static constexpr uint32_t TICKS_PER_USEC = 1;

    /// Called once during construction time.
    static void module_init();

    /// Called inline with Device::enable().
    static void module_enable();

    /// Called inline with Device::disable().
    static void module_disable();

    /// Calls a software interrupt.
    static void trigger_os_interrupt() {
        NVIC_SetPendingIRQ(HW::OS_IRQn);
    }

    /// hook
    static void before_cutout_hook() {
        HW::before_cutout_hook();
    }

    /// hook
    static void dcc_before_cutout_hook() {
        HW::dcc_before_cutout_hook();
    }
    
    /// hook
    static void dcc_packet_finished_hook() {
        HW::dcc_packet_finished_hook();
    }

    /// hook
    static void after_feedback_hook() {
        HW::after_feedback_hook();
    }
    
    /// Called from the capture interrupt handler. Checks interrupt status,
    /// clears interrupt.
    /// @return true if the interrupt was generated by a capture event.
    static inline bool int_get_and_clear_capture_event();

    /// Called from the interrupt handler if int_get_and_clear_capture_event
    /// said yes.
    /// @return the value of the downcounting capture at the time when the edge
    /// was captured.
    static inline uint32_t get_capture_counter();

    /// Called from the timeout interrupt handler. Checks interrupt status,
    /// clears timer expired interrupt.
    /// @return true if the interrupt was generated by the timer_delay_usec
    /// expiring event.
    static inline bool int_get_and_clear_delay_event();

    
    /// Delays a give number of usec using the capture timer feature. Needed
    /// for the timing ofthe railcom cutout.
    /// @param usec how much to delay.
    static void set_cap_timer_delay_usec(int usec)
    {
        Debug::DccPacketDelay::toggle();
        // This code handles underflow of the timer correctly. We cannot wait
        // longer than one full cyucle though (65 msec -- typical RailCom waits
        // are 20-500 usec).
        uint32_t new_match_v = __HAL_TIM_GET_COUNTER(usec_timer_handle()) +
                                TIMER_MAX_VALUE + 1 - usec;
        new_match_v &= 0xffff;
        __HAL_TIM_SET_COMPARE(
            usec_timer_handle(), HW::USEC_CHANNEL, new_match_v);
        __HAL_TIM_CLEAR_IT(usec_timer_handle(), HW::USEC_IF);
        __HAL_TIM_ENABLE_IT(usec_timer_handle(), HW::USEC_IF);
    }

    /// Sets the timer to capture mode. Needed for the digitization of DCC
    /// signal bits.
    static void set_cap_timer_capture()
    {
        TIM_IC_InitTypeDef     channel_init;
        memset(&channel_init, 0, sizeof(channel_init));
        channel_init.ICPolarity = TIM_ICPOLARITY_BOTHEDGE;
        channel_init.ICSelection = TIM_ICSELECTION_DIRECTTI;
        channel_init.ICPrescaler = TIM_ICPSC_DIV1;
        channel_init.ICFilter = HW::CAPTURE_FILTER;
        HASSERT(HAL_TIM_IC_ConfigChannel(capture_timer_handle(), &channel_init,
                    HW::CAPTURE_CHANNEL) == HAL_OK);

        HASSERT(
            HAL_TIM_IC_Start_IT(capture_timer_handle(), HW::CAPTURE_CHANNEL) == HAL_OK);
    }

    /// Sets the timer to oneshot (timer) mode. Called once, then
    /// set_cap_timer_delay_usec() will be called multiple times, expecting
    /// each to deliver an rcom_interrupt().
    static void set_cap_timer_time()
    {
        TIM_OC_InitTypeDef channel_init;
        memset(&channel_init, 0, sizeof(channel_init));
        channel_init.OCMode = TIM_OCMODE_TIMING; // frozen -- no output
        channel_init.Pulse = (__HAL_TIM_GET_COUNTER(usec_timer_handle()) + 1) &
            0xffff; // will be reloaded in the delay_usec function.
        // the rest are irrelevant.
        channel_init.OCPolarity = TIM_OCPOLARITY_HIGH;
        channel_init.OCNPolarity  = TIM_OCNPOLARITY_HIGH;
        channel_init.OCFastMode   = TIM_OCFAST_DISABLE;
        channel_init.OCIdleState  = TIM_OCIDLESTATE_RESET;
        channel_init.OCNIdleState = TIM_OCNIDLESTATE_RESET;
        HASSERT(HAL_TIM_OC_ConfigChannel(usec_timer_handle(), &channel_init,
                    HW::USEC_CHANNEL) == HAL_OK);

        HASSERT(HAL_TIM_OC_Start_IT(usec_timer_handle(), HW::USEC_CHANNEL) ==
            HAL_OK);
        // Disable interrupt until the delay_usec() is called.
        __HAL_TIM_DISABLE_IT(usec_timer_handle(), HW::USEC_IF);
    }

    /// Called once inline in an interrupt. Signals that the delay timer is not
    /// needed anymore.
    static void stop_cap_timer_time()
    {
        __HAL_TIM_DISABLE_IT(usec_timer_handle(), HW::USEC_IF);
        TIM_CCxChannelCmd(
            usec_timer(), HW::USEC_CHANNEL, TIM_CCx_DISABLE);
    }


private:
    static TIM_HandleTypeDef captureTimerHandle_;
    static TIM_HandleTypeDef usecTimerHandle_;

    /// Initializes a timer resource (shared for all channels).
    /// @param handle pointer to the HAL timer handle.
    /// @param instance pointer to the timer registers, such as TIM3.
    static void init_timer(TIM_HandleTypeDef *handle, TIM_TypeDef *instance)
    {
        memset(handle, 0, sizeof(*handle));
        handle->Instance = instance;
        handle->Init.Period = 0xFFFF;
        // 1 usec per tick
        handle->Init.Prescaler = configCPU_CLOCK_HZ / 1000000;
        handle->Init.ClockDivision = 0;
        handle->Init.CounterMode = TIM_COUNTERMODE_DOWN;
        handle->Init.RepetitionCounter = 0;
        handle->Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;

        HASSERT(HAL_TIM_IC_Init(handle) == HAL_OK);
    }

    /// @return the hardware pointer to the capture timer.
    static TIM_TypeDef* capture_timer() {
        return reinterpret_cast<TIM_TypeDef*>(HW::CAPTURE_TIMER);
    }
    /// @return the HAL handle to the capture timer.
    static TIM_HandleTypeDef* capture_timer_handle() {
        return &captureTimerHandle_;
    }
    
    /// @return the hardware pointer to the usec timer.
    static TIM_TypeDef* usec_timer() {
        return reinterpret_cast<TIM_TypeDef*>(HW::USEC_TIMER);
    }
    /// @return the HAL handle to the usec timer (which may alias to the
    /// capture timer handle).
    static TIM_HandleTypeDef* usec_timer_handle() {
        if (shared_timers()) {
            return capture_timer_handle();
        }
        return &usecTimerHandle_;
    }
    
    /// @return true if the same timer resource (on different channels) is used
    /// for both the capture and the usec timer.
    static bool shared_timers() {
        return HW::CAPTURE_TIMER == HW::USEC_TIMER;
    }
    
    /// Private constructor. This class cannot be instantiated.
    Stm32DccTimerModule();
    
    DISALLOW_COPY_AND_ASSIGN(Stm32DccTimerModule);
};

template <class HW>
TIM_HandleTypeDef Stm32DccTimerModule<HW>::captureTimerHandle_;
template <class HW> TIM_HandleTypeDef Stm32DccTimerModule<HW>::usecTimerHandle_;

template <class HW>
void Stm32DccTimerModule<HW>::module_init()
{
    memset(&captureTimerHandle_, 0, sizeof(captureTimerHandle_));
    memset(&usecTimerHandle_, 0, sizeof(usecTimerHandle_));
    NRZ_Pin::hw_init();
}

template <class HW> void Stm32DccTimerModule<HW>::module_enable()
{
    init_timer(capture_timer_handle(), capture_timer());
    
    GPIO_InitTypeDef gpio_init;
    memset(&gpio_init, 0, sizeof(gpio_init));
    gpio_init.Mode = GPIO_MODE_AF_PP;
    gpio_init.Pull = GPIO_PULLUP;
    gpio_init.Speed = GPIO_SPEED_FREQ_HIGH;
    gpio_init.Alternate = HW::CAPTURE_AF_MODE;
    gpio_init.Pin = HW::NRZ_Pin::pin();
    HAL_GPIO_Init(HW::NRZ_Pin::port(), &gpio_init);

    set_cap_timer_capture();

    if (!shared_timers())
    {
        init_timer(usec_timer_handle(), usec_timer());
    }

#if defined(GCC_ARMCM0)    
    HAL_NVIC_SetPriority(HW::CAPTURE_IRQn, 0, 0);
    HAL_NVIC_SetPriority(HW::TIMER_IRQn, 0, 0);
    HAL_NVIC_SetPriority(HW::OS_IRQn, 3, 0);
#elif defined(GCC_ARMCM3)    
    NVIC_SetPriority(HW::CAPTURE_IRQn, 0x20);
    NVIC_SetPriority(HW::TIMER_IRQn, 0x20);
    NVIC_SetPriority(HW::OS_IRQn, configKERNEL_INTERRUPT_PRIORITY);
#else
#error not defined how to set interrupt priority
#endif    
    
    NVIC_EnableIRQ(HW::CAPTURE_IRQn);
    NVIC_EnableIRQ(HW::TIMER_IRQn);
    NVIC_EnableIRQ(HW::OS_IRQn);
}

template <class HW> void Stm32DccTimerModule<HW>::module_disable()
{
    capture_timer_handle()->Instance = capture_timer();
    usec_timer_handle()->Instance = usec_timer();
    NVIC_DisableIRQ(HW::CAPTURE_IRQn);
    NVIC_DisableIRQ(HW::TIMER_IRQn);
    NVIC_DisableIRQ(HW::OS_IRQn);
    HASSERT(HAL_TIM_IC_Stop_IT(capture_timer_handle(), HW::CAPTURE_CHANNEL) ==
        HAL_OK);

    HASSERT(
        HAL_TIM_OC_Stop_IT(usec_timer_handle(), HW::USEC_CHANNEL) == HAL_OK);
    if (!shared_timers())
    {
        HASSERT(HAL_TIM_IC_DeInit(usec_timer_handle()) == HAL_OK);
    }
    HASSERT(HAL_TIM_IC_DeInit(capture_timer_handle()) == HAL_OK);
}

template <class HW>
bool Stm32DccTimerModule<HW>::int_get_and_clear_capture_event()
{
    if (__HAL_TIM_GET_FLAG(capture_timer_handle(), HW::CAPTURE_IF)) {
        //Debug::DccDecodeInterrupts::toggle();
        HW::cap_event_hook();
        __HAL_TIM_CLEAR_FLAG(capture_timer_handle(), HW::CAPTURE_IF);
        // TODO(balazs.racz): Technically it is possible that the timer reload
        // happens between the event match and the interrupt entry. In this
        // case we will incorrectly add a full cycle to the event length.
        return true;
    }
    return false;
}

template <class HW>
uint32_t Stm32DccTimerModule<HW>::get_capture_counter()
{
    return HAL_TIM_ReadCapturedValue(
        capture_timer_handle(), HW::CAPTURE_CHANNEL);
}

template <class HW>
bool Stm32DccTimerModule<HW>::int_get_and_clear_delay_event()
{
    if (__HAL_TIM_GET_FLAG(usec_timer_handle(), HW::USEC_IF)) {
        Debug::DccDecodeInterrupts::set(true);
        __HAL_TIM_CLEAR_IT(usec_timer_handle(), HW::USEC_IF);
        // we also disable the interrupt until it is reenabled by loading a new
        // usec delay target.
        __HAL_TIM_DISABLE_IT(usec_timer_handle(), HW::USEC_IF);
        return true;
    }
    return false;
}

template<class HW> using Stm32DccDecoder = DccDecoder<Stm32DccTimerModule<HW> >;
