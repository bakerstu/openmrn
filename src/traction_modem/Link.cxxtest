#include "utils/test_main.hxx"
#include "traction_modem/Link.hxx"

#include <linux/sockios.h>
#include <sys/ioctl.h>

#include "os/FakeClock.hxx"
#include "traction_modem/modem_test_helper.hxx"

namespace traction_modem
{

//
// Mock objects.
//
class MockLinkCallback : public LinkStatusInterface
{
public:
    MOCK_METHOD0(link_start, void());
    MOCK_METHOD0(link_up, void());
    MOCK_METHOD0(link_down, void());
};

class LinkTest : public ::testing::Test
{
protected:
    /// Constructor.
    LinkTest()
        : link_(&g_service, &mTxFlow_, &mRxFlow_)
        , linkManager_(&g_service, &link_)
    {
        link_.register_link_status(&mLinkCback_);

        using ::testing::StartsWith;
        using namespace std::literals;

        ::testing::Sequence s1, s2;

        EXPECT_CALL(mTxFlow_, start(50)).Times(1).InSequence(s1);
        EXPECT_CALL(mRxFlow_, start(50)).Times(1).InSequence(s2);
        EXPECT_CALL(mLinkCback_, link_start()).Times(1).InSequence(s1, s2);
        EXPECT_CALL(mRxFlow_, register_handler(
            &linkManager_, Defs::RESP_PING, Message::EXACT_MASK)).Times(1)
            .InSequence(s1, s2);
        EXPECT_CALL(mTxFlow_, send_packet(StartsWith(
            "\x41\xD2\xC3\x7A\x00\x00\x00\x00"s))).Times(1).InSequence(s1, s2);
        link_.start(50);
        wait_for_main_executor();
        testing::Mock::VerifyAndClearExpectations(&mTxFlow_);
        testing::Mock::VerifyAndClearExpectations(&mRxFlow_);
        testing::Mock::VerifyAndClearExpectations(&mLinkCback_);
    }

    /// Destructor.
    ~LinkTest()
    {
        using ::testing::StartsWith;
        using namespace std::literals;
        wait_for_main_executor();
        testing::Mock::VerifyAndClearExpectations(&mTxFlow_);
        testing::Mock::VerifyAndClearExpectations(&mRxFlow_);
        testing::Mock::VerifyAndClearExpectations(&mLinkCback_);
        EXPECT_CALL(mRxFlow_, unregister_handler(
            &linkManager_, Defs::RESP_PING, Message::EXACT_MASK))
            .Times(::testing::AtLeast(0));
        EXPECT_CALL(mRxFlow_, unregister_handler(
            &linkManager_, Defs::RESP_BAUD_RATE_QUERY,
            Message::EXACT_MASK)).Times(::testing::AtLeast(0));
        EXPECT_CALL(mTxFlow_, send_packet(StartsWith(
            "\x41\xD2\xC3\x7A\x00\x00\x00\x00"s))).Times(::testing::AtLeast(0));
        EXPECT_CALL(mLinkCback_, link_down()).Times(::testing::AtLeast(0));
        linkManager_.TEST_shutdown();
        clk_advance(SEC_TO_NSEC(4));
        wait_for_main_timers();
    }

    /// Fake clock helper
    /// @param nsec how far to advance in nanoseconds
    /// @param step_size_msec step size in milliseconds
    void clk_advance(long long nsec, unsigned step_size_msec = 10)
    {
        while (nsec > 0)
        {
            nsec -= MSEC_TO_NSEC(step_size_msec);
            clk_.advance(MSEC_TO_NSEC(step_size_msec));
            wait_for_main_executor();
        }
    }

    FakeClock clk_;
    ::testing::StrictMock<MockTxFlow> mTxFlow_;
    ::testing::StrictMock<MockRxFlow> mRxFlow_;
    ::testing::StrictMock<MockLinkCallback> mLinkCback_;
    Link link_;
    LinkManager linkManager_;
};

TEST_F(LinkTest, Create)
{
    EXPECT_FALSE(link_.is_link_up());
}

TEST_F(LinkTest, StartAgain)
{
    EXPECT_CALL(mLinkCback_, link_start()).Times(0);
    link_.start(50);
    testing::Mock::VerifyAndClearExpectations(&mLinkCback_);
    EXPECT_FALSE(link_.is_link_up());
}

TEST_F(LinkTest, LinkUpDownDefaultBaud)
{
    using ::testing::StartsWith;
    using namespace std::literals;

    //
    // Send the ping response (pong).
    //
    {
        ::testing::Sequence s1;
        EXPECT_CALL(mRxFlow_, unregister_handler(
            &linkManager_, Defs::RESP_PING, Message::EXACT_MASK)).Times(1)
            .InSequence(s1);
        EXPECT_CALL(mLinkCback_, link_up()).Times(1).InSequence(s1);
        EXPECT_CALL(mRxFlow_, register_handler(
            &linkManager_, Defs::RESP_PING, Message::EXACT_MASK)).Times(1)
            .InSequence(s1);
        EXPECT_FALSE(link_.is_link_up());
        // Now send the ping response.
        auto b = linkManager_.alloc();
        Defs::prepare(&b->data()->payload, Defs::RESP_PING, 4);
        Defs::append_uint8(&b->data()->payload, 0);
        Defs::append_uint8(&b->data()->payload, 0);
        Defs::append_uint8(&b->data()->payload, 0);
        Defs::append_uint8(&b->data()->payload, 0);
        Defs::append_crc(&b->data()->payload);
        static_cast<PacketFlowInterface*>(&linkManager_)->send(b);
        wait_for_main_executor();
        testing::Mock::VerifyAndClearExpectations(&mTxFlow_);
        testing::Mock::VerifyAndClearExpectations(&mRxFlow_);
        testing::Mock::VerifyAndClearExpectations(&mLinkCback_);
        EXPECT_TRUE(link_.is_link_up());
    }

    //
    // Wait over 3 seconds without a ping response (pong).
    //
    {
        ::testing::Sequence s1;
        EXPECT_CALL(mTxFlow_, send_packet(StartsWith(
            "\x41\xD2\xC3\x7A\x00\x00\x00\x00"s))).Times(1).InSequence(s1);
        EXPECT_CALL(mRxFlow_, unregister_handler(
            &linkManager_, Defs::RESP_PING, Message::EXACT_MASK)).Times(1)
            .InSequence(s1);
        EXPECT_CALL(mLinkCback_, link_down()).Times(1).InSequence(s1);
        EXPECT_CALL(mRxFlow_, register_handler(
            &linkManager_, Defs::RESP_PING, Message::EXACT_MASK)).Times(1)
            .InSequence(s1);
        EXPECT_CALL(mTxFlow_, send_packet(StartsWith(
            "\x41\xD2\xC3\x7A\x00\x00\x00\x00"s))).Times(1).InSequence(s1);
        clk_advance(MSEC_TO_NSEC(3010));
        testing::Mock::VerifyAndClearExpectations(&mTxFlow_);
        testing::Mock::VerifyAndClearExpectations(&mRxFlow_);
        testing::Mock::VerifyAndClearExpectations(&mLinkCback_);
        EXPECT_FALSE(link_.is_link_up());
    }
}

TEST_F(LinkTest, LinkUpTimeoutBaudRateQuery)
{
    linkManager_.TEST_disable_default_baud();

    using ::testing::StartsWith;
    using namespace std::literals;

    //
    // Send the ping response (pong).
    //
    {
        ::testing::Sequence s1;
        EXPECT_CALL(mRxFlow_, unregister_handler(
            &linkManager_, Defs::RESP_PING, Message::EXACT_MASK)).Times(1)
            .InSequence(s1);
        EXPECT_CALL(mRxFlow_, register_handler(
            &linkManager_, Defs::RESP_BAUD_RATE_QUERY,
            Message::EXACT_MASK)).Times(1).InSequence(s1);
        EXPECT_CALL(mTxFlow_, send_packet(StartsWith(
            "\x41\xD2\xC3\x7A\x00\x03\x00\x00"s))).Times(1).InSequence(s1);
        clk_advance(MSEC_TO_NSEC(990));
        auto b = linkManager_.alloc();
        Defs::prepare(&b->data()->payload, Defs::RESP_PING, 4);
        Defs::append_uint8(&b->data()->payload, 0);
        Defs::append_uint8(&b->data()->payload, 0);
        Defs::append_uint8(&b->data()->payload, 0);
        Defs::append_uint8(&b->data()->payload, 0);
        Defs::append_crc(&b->data()->payload);
        static_cast<PacketFlowInterface*>(&linkManager_)->send(b);
        wait_for_main_executor();
        testing::Mock::VerifyAndClearExpectations(&mTxFlow_);
        testing::Mock::VerifyAndClearExpectations(&mRxFlow_);
        EXPECT_FALSE(link_.is_link_up());
    }

    //
    // Do not send a baud rate query response, timeout, expect another ping and
    // link down.
    //
    {
        ::testing::Sequence s1;
        EXPECT_CALL(mRxFlow_, unregister_handler(
            &linkManager_, Defs::RESP_BAUD_RATE_QUERY, Message::EXACT_MASK))
            .Times(1).InSequence(s1);
        EXPECT_CALL(mRxFlow_, register_handler(
            &linkManager_, Defs::RESP_PING, Message::EXACT_MASK)).Times(1)
            .InSequence(s1);
        EXPECT_CALL(mTxFlow_, send_packet(StartsWith(
            "\x41\xD2\xC3\x7A\x00\x00\x00\x00"s))).Times(1).InSequence(s1);
        clk_advance(MSEC_TO_NSEC(1010));
        testing::Mock::VerifyAndClearExpectations(&mTxFlow_);
        testing::Mock::VerifyAndClearExpectations(&mRxFlow_);
        EXPECT_FALSE(link_.is_link_up());
    }
}

TEST_F(LinkTest, LinkUpMaxDelay)
{
    linkManager_.TEST_disable_default_baud();

    using ::testing::StartsWith;
    using namespace std::literals;

    //
    // Send the ping response (pong).
    //
    {
        ::testing::Sequence s1;
        EXPECT_CALL(mRxFlow_, unregister_handler(
            &linkManager_, Defs::RESP_PING, Message::EXACT_MASK)).Times(1)
            .InSequence(s1);
        EXPECT_CALL(mRxFlow_, register_handler(
            &linkManager_, Defs::RESP_BAUD_RATE_QUERY,
            Message::EXACT_MASK)).Times(1).InSequence(s1);
        EXPECT_CALL(mTxFlow_, send_packet(StartsWith(
            "\x41\xD2\xC3\x7A\x00\x03\x00\x00"s))).Times(1).InSequence(s1);
        clk_advance(MSEC_TO_NSEC(990));
        auto b = linkManager_.alloc();
        Defs::prepare(&b->data()->payload, Defs::RESP_PING, 4);
        Defs::append_uint8(&b->data()->payload, 0);
        Defs::append_uint8(&b->data()->payload, 0);
        Defs::append_uint8(&b->data()->payload, 0);
        Defs::append_uint8(&b->data()->payload, 0);
        Defs::append_crc(&b->data()->payload);
        static_cast<PacketFlowInterface*>(&linkManager_)->send(b);
        wait_for_main_executor();
        testing::Mock::VerifyAndClearExpectations(&mTxFlow_);
        testing::Mock::VerifyAndClearExpectations(&mRxFlow_);
        EXPECT_FALSE(link_.is_link_up());
    }

    //
    // Send the baud rate query response of 250 Kbps only, expect link up.
    //
    {
        ::testing::Sequence s1;
        EXPECT_CALL(mRxFlow_, unregister_handler(
            &linkManager_, Defs::RESP_BAUD_RATE_QUERY, Message::EXACT_MASK))
            .Times(1).InSequence(s1);
        EXPECT_CALL(mLinkCback_, link_up()).Times(1).InSequence(s1);
        EXPECT_CALL(mRxFlow_, register_handler(
            &linkManager_, Defs::RESP_PING, Message::EXACT_MASK)).Times(1)
            .InSequence(s1);
        clk_advance(MSEC_TO_NSEC(990));
        auto b = linkManager_.alloc();
        Defs::prepare(&b->data()->payload, Defs::RESP_BAUD_RATE_QUERY, 2);
        Defs::append_uint16(&b->data()->payload, Defs::BAUD_250K_MASK);
        Defs::append_crc(&b->data()->payload);
        static_cast<PacketFlowInterface*>(&linkManager_)->send(b);
        wait_for_main_executor();
        testing::Mock::VerifyAndClearExpectations(&mLinkCback_);
        testing::Mock::VerifyAndClearExpectations(&mRxFlow_);
        EXPECT_TRUE(link_.is_link_up());
    }

    // Expect a ping every 2 seconds.
    clk_advance(MSEC_TO_SEC(10));
    for (unsigned i = 0; i < 10; ++i)
    {
        // Expect a ping after 2 seconds
        EXPECT_CALL(mTxFlow_, send_packet(StartsWith(
            "\x41\xD2\xC3\x7A\x00\x00\x00\x00"s))).Times(1);
        clk_advance(MSEC_TO_NSEC(2000));
        testing::Mock::VerifyAndClearExpectations(&mTxFlow_);
        // Send a ping response (pong) back.
        auto b = linkManager_.alloc();
        Defs::prepare(&b->data()->payload, Defs::RESP_PING, 4);
        Defs::append_uint8(&b->data()->payload, 0);
        Defs::append_uint8(&b->data()->payload, 0);
        Defs::append_uint8(&b->data()->payload, 0);
        Defs::append_uint8(&b->data()->payload, 0);
        Defs::append_crc(&b->data()->payload);
        static_cast<PacketFlowInterface*>(&linkManager_)->send(b);
        wait_for_main_executor();
        testing::Mock::VerifyAndClearExpectations(&mTxFlow_);
        EXPECT_TRUE(link_.is_link_up());
    }
}

} // traction modem