#include "utils/test_main.hxx"
#include "os/FakeClock.hxx"
#include "os/os.h"

#include "traction_modem/TractionModem.hxx"

using namespace tractionmodem;
using namespace std::string_literals;

//
// Mock objects.
//
class TestPacketFlowInterface : public PacketFlowInterface
{
public:
    virtual void send(std::string &m, unsigned priority) = 0;

    virtual void send(
        Buffer<TxMessage> *message, unsigned priority = UINT_MAX) override
    {
        send(message->data()->payload, priority);
    }
};

class MockPacketFlowInterface : public TestPacketFlowInterface
{
public:
    MOCK_METHOD2(send, void(std::string &, unsigned));
};

/// Test object for the TxFlow
class TxFlowTest : public ::testing::Test
{
protected:
    /// Constructor.
    TxFlowTest()
    {
    }

    /// Destructor.
    ~TxFlowTest()
    {
        wait_for_main_executor();
        close(fd_[0]);
        close(fd_[1]);
    }

    /// Initialization helper that starts the Flow.
    void init()
    {
        pipe(fd_);
        for (unsigned i = 0; i < 2; ++i)
        {
            int opt = fcntl(fd_[i], F_GETFL);
            opt |= O_NONBLOCK;
            fcntl(fd_[i], F_SETFL, opt);
        }
        flow_.start(fd_[1]);
    }

    /// Helper to receive all the data from the pipe.
    /// @return string containing all the data from the pipe
    std::string recv()
    {
        std::string data;
        int result;
        char buf[32];
        do
        {
            result = read(fd_[0], buf, sizeof(buf));
            if (result > 0)
            {
                data.append(buf, result);
            }
        } while (result > 0);

        return data;
    }

    int fd_[2]; ///< pipe FDs
    TxFlow flow_{&g_service}; ///< flow instance under test
};

/// Test object for the RxFlow
class RxFlowTest : public ::testing::Test
{
protected:
    /// Constructor.
    RxFlowTest()
    {
    }

    /// Destructor.
    ~RxFlowTest()
    {
        testing::Mock::VerifyAndClearExpectations(&mPFI_);
        // Trigger the flow to exit.
        flow_.exit_ = true;
        std::string dummy(1000, '\0');
        write(fd_[1], dummy.data(), dummy.size());

        // Wait for exit.
        wait_for_main_executor();
        while (!g_executor.active_timers()->empty())
        {
            usleep(20000);
            wait_for_main_executor();
        }
        wait_for_main_executor();
        close(fd_[0]);
        close(fd_[1]);
    }

    /// Initialization helper that starts the Flow.
    void init()
    {
        pipe(fd_);
        // Only make the read pipe non-blocking.
        int opt = fcntl(fd_[0], F_GETFL);
        opt |= O_NONBLOCK;
        fcntl(fd_[0], F_SETFL, opt);
        flow_.start(fd_[0]);
        wait_for_main_executor();
    }

    /// Helper to send all the data to the pipe.
    /// @param data data to send
    void send(const std::string &data)
    {
        LOG(ALWAYS, "[TestTx]  sent len:%3zu, data: %s", data.size(),
            string_to_hex(data).c_str());
        int result = write(fd_[1], data.data(), data.size());
        // We don't really care about this expectation because it should always
        // pass. We are using it as a catch that something went very wrong.
        EXPECT_EQ(result, (int)data.size());
    }

    int fd_[2]; ///< pipe FDs
    RxFlow flow_{&g_service}; ///< flow instance under test

    /// Mock packet flow interface.
    ::testing::StrictMock<MockPacketFlowInterface> mPFI_;
};

//
// TxFlowTest::CreateNoStart
//
TEST_F(TxFlowTest, CreateNoStart)
{
    auto b = flow_.alloc();
    b->data()->payload = std::move(Defs::get_fn_set_payload(10, 1));
    flow_.send(b);
}

//
// TxFlowTest::Write
//
TEST_F(TxFlowTest, Write)
{
    std::string result;
    std::string expected;
    init();

    auto b = flow_.alloc();
    b->data()->payload = std::move(Defs::get_fn_set_payload(10, 1));
    flow_.send(b);
    wait_for_main_executor();

    result = recv();
    expected = "\x41\xd2\xc3\x7a"s "\x01\x01"s "\x00\x06"s
               "\x00\x00\x00\x0A\x00\x01"s "\x00\x00\x00\x00\x00\x00"s;
    EXPECT_EQ(expected, result);
}

//
// RxFlowTest::CreateNoStart
//
TEST_F(RxFlowTest, CreateNoStart)
{
}

//
// RxFlowTest::Read
//
TEST_F(RxFlowTest, Read)
{
    using ::testing::_;

    std::string data;
    init();
    
    data = "\x41\xd2\xc3\x7a"s "\x01\x01"s "\x00\x06"s
           "\x00\x00\x00\x0A\x00\x01"s "\x00\x00\x00\x00\x00\x00"s;

    // Send a packet without a registered receiver.
    EXPECT_CALL(mPFI_, send(_, _)).Times(0);
    send(data);
    wait_for_main_executor();
    testing::Mock::VerifyAndClearExpectations(&mPFI_);

    // All the data should have been pulled from the pipe. Since there is no
    // receiver, it gets thrown on the floor.
    {
        uint8_t dummy[4];
        int result = read(fd_[0], dummy, sizeof(dummy));
        EXPECT_LT(result, 0);
        EXPECT_EQ(EAGAIN, errno);
    }

    // Register a receiver and make sure it gets the next sent message.
    flow_.set_listener(&mPFI_);
    EXPECT_CALL(mPFI_, send(testing::Eq(data), UINT_MAX)).Times(1);
    send(data);
    wait_for_main_executor();
    testing::Mock::VerifyAndClearExpectations(&mPFI_);

    // Send a message in pieces in order to exercise some of the other paths.
    send(data.substr(0, 1));
    wait_for_main_executor();
    send(data.substr(1, 4));
    wait_for_main_executor();
    EXPECT_CALL(mPFI_, send(testing::Eq(data), UINT_MAX)).Times(1);
    send(data.substr(5, data.size() - 5));
    wait_for_main_executor();
}

//
// RxFlowTest::Rsync
//
TEST_F(RxFlowTest, Rsync)
{
    using ::testing::_;

    std::string good_data;
    std::string bad_data;
    std::string bad_size;
    std::string big_size;
    init();
    // Register a receiver.
    flow_.set_listener(&mPFI_);

    // This is an actual valid packet.
    good_data = "\x41\xd2\xc3\x7a"s "\x01\x01"s "\x00\x06"s
                "\x00\x00\x00\x0A\x00\x01"s "\x00\x00\x00\x00\x00\x00"s;
    // This is just garbage. Something to fill the space and force resync.
    bad_data = "\x89\x06\xdc\x7a\x41\x01\x06\x06\x00\x00\xaa\xab\x74\x01"s
               "\x05\x30\x56\x89\x82\x01"s;
    // Invalid size, too large
    bad_size = "\x02\x01"s;
    // Valid size, but just really large.
    big_size = "\x01\x00"s;

    //
    // Start sending a valid packet, but skip the last preamble byte.
    //
    EXPECT_CALL(mPFI_, send(_, _)).Times(0);
    send(good_data.substr(0, 3));
    send(good_data.substr(5, good_data.size() - 5));
    wait_for_main_executor();
    testing::Mock::VerifyAndClearExpectations(&mPFI_);

    //
    // Send a "good" packet header, but with too large data size. +
    // ...send a bit of bad data +
    // ...send a valid packet acn expect a resync and successful reception
    //
    EXPECT_CALL(mPFI_, send(testing::Eq(good_data), UINT_MAX)).Times(1);
    send(good_data.substr(0, 6) + bad_size + bad_data.substr(0, 6) + good_data);
    wait_for_main_executor();
    testing::Mock::VerifyAndClearExpectations(&mPFI_);

    //
    // Test the timeout waiting for packet data.
    //
    FakeClock clk;
    EXPECT_CALL(mPFI_, send(_, _)).Times(0);
    send(good_data.substr(0, 8 + 6)); // Send the header plus some data.
    wait_for_main_executor();
    send(good_data.substr(8, 4)); // Send some more of the data/crc, not all.
    wait_for_main_executor();
    clk.advance(2 * flow_.get_character_nsec() * (6 + 2));
    wait_for_main_executor();

    // Ensure that we can still recover and decode the next full good packet.
    flow_.set_listener(&mPFI_);
    EXPECT_CALL(mPFI_, send(testing::Eq(good_data), UINT_MAX)).Times(1);
    send(good_data);
    wait_for_main_executor();
    testing::Mock::VerifyAndClearExpectations(&mPFI_);
}